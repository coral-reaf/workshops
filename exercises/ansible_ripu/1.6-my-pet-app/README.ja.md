# ワークショップ演習 - ペット アプリのデプロイ

## 目次

- [ワークショップ演習 - ペットアプリのデプロイ](#ワークショップ演習---ペットアプリのデプロイ)
  - [目次](#目次)
  - [オプション演習](#オプション演習)
  - [目標](#目標)
  - [ガイド](#ガイド)
    - [Step 1 - 従来のアプリケーションライフサイクル](#step-1---従来のアプリケーションライフサイクル)
    - [Step 2 - 愛するペットアプリケーションのインストール](#step-2---愛するペットアプリケーションのインストール)
    - [Step 3 - ペットアプリケーションのテスト](#step-3---ペットアプリケーションのテスト)
    - [Step 4 - 再起動時にアプリケーションが起動するように構成](#step-4---再起動時にアプリケーションが起動するように構成)
    - [Step 5 - 別のアップグレード前レポートを実行する](#step-5---別のアップグレード前レポートの実行)
  - [まとめ](#まとめ)

## オプション演習

これはオプションの演習です。ワークショップを正常に完了するために必須ではありませんが、時間に余裕があれば試してみることをお勧めします。次のセクションに記載されている目標を確認して、この演習を行うか、それとも次の演習に進むかを決めてください。

* [演習 2.1 - OS アップグレード ジョブを実行する](../2.1-upgrade/README.ja.md)

## 目標

* 従来のサーバー環境でアプリケーションがどのように展開および維持されるかについて説明します
* サンプルのペット アプリケーションをインストールするか、独自のアプリケーションを用意します
* アプリケーションが期待どおりに機能しているかどうかをテストする方法を検討します

## ガイド

### Step 1 - 従来のアプリケーション ライフサイクル

少し立ち止まって、インプレース アップグレードを実行する理由について考えてみましょう。新しい RHEL バージョンで新しいサーバーまたは VM インスタンスを展開し、そこからアプリケーションの新規インストールを行うのがベスト プラクティスではないでしょうか。

- はい、でも...

  - アプリ チームがアプリの展開を自動化しておらず、代わりにすべてを手動でインストールして構成している場合はどうでしょうか。

  - 何年も前にアプリをインストールして以来、問題を解決したり、変化するビジネス要件に対応したりするために、アプリ環境に変更を加えてきた場合はどうでしょうか?

  - 蓄積されたドリフトや技術的負債をすべて把握できなくなり、一からやり直すのが非常に困難になった場合はどうでしょうか?

- 残念ながら、多くのアプリ チームがこのような状況に陥っています。従来のアプリ サーバーは、長年、愛するペットのように大切に扱われてきました。それを捨てて、すべてを最初からやり直すという考えは考えられません。

- アプリケーションに触れることなく、新しい RHEL バージョンに移行できるのであれば、それは非常に魅力的な選択肢です。そのため、インプレース アップグレードを行い、すべてを手動でインストールして再構成するという面倒な作業に悩まされることなく、企業のプラットフォーム ライフサイクル コンプライアンス レポートから姿を消すことを望んでいます。

- このオプションの演習では、アプリケーションをインストールして、RHEL インプレース アップグレードが何らかの影響を与えるかどうかを評価します。アップグレード後も、新しい RHEL バージョンでアプリが期待どおりに機能するかどうかを確認します。

### Step 2 - 愛するペットアプリケーションのインストール

このステップでは、サンプル アプリケーションをインストールします。インストールは昔ながらの方法で行います。つまり、混乱を招き、エラーが発生しやすい可能性がある従来のコマンドライン 手順に従って手動でインストールします。結局のところ、アプリケーションのデプロイメントがエンドツーエンドで自動化されていれば、インプレース アップグレードを行う必要はありません。

別のアプリケーション (たとえば、潜在的な影響をテストしたいエンタープライズ環境の実際のアプリケーション) をインストールすることもできます。以下の手順をスキップして、独自の冒険をしてください。アップグレードの前後でアプリケーションをテストするようにしてください。

- サンプル アプリケーションは、Java で記述された [Spring Pet Clinic サンプル アプリケーション](https://github.com/spring-projects/spring-petclinic) です。これは、Maven を使用して構築される Spring Boot アプリケーションです。起動時にサンプル データが入力される MySQL データベースに接続します。

> **注意**
>
> 以下の手順では、サンプル アプリケーションを手動でインストールして起動するために必要なコマンドを段階的に実行します。これは、企業内で従来の古いアプリケーションがどのようにデプロイされているかを模倣するために行われます。一連のコマンドを手動で実行する代わりにショートカットを使用する場合は、「PETS / App Install」ジョブ テンプレートを起動してサンプル アプリケーションをデプロイできます。
>
> アプリケーションのインストール ジョブが成功した場合は、[Step 3 - ペットアプリケーションのテスト](#step-3---ペットアプリケーションのテスト) に進んでください。
>

- アプリケーションのインストール手順の最初のステップは、Java JDK をインストールすることです。ここでは、楽しみのためにサードパーティの JDK を使用します。
> **警告**
>
> すべてのコマンドは、root ではなく ec2-user として実行する必要があります。root を必要とするコマンドでは、`sudo` が使用されます。

ペット アプリ サーバーにログインし、次のコマンドを実行します:

```
distver=$(sed -r 's/([^:]*:){4}//;s/(.).*/\1/' /etc/system-release-cpe)
sudo yum-config-manager --add-repo=https://packages.adoptium.net/artifactory/rpm/rhel/$distver/x86_64
sudo yum-config-manager --save --setopt=\*adoptium\*.gpgkey=https://packages.adoptium.net/artifactory/api/gpg/key/public
sudo yum install mariadb mariadb-server temurin-17-jdk
```

最後のコマンドからのプロンプトにはすべて `y` と答えます。

- temurin-17-jdk パッケージがインストールされていることを確認します:

```
rpm -q temurin-17-jdk
```

そうでない場合は、戻って何が間違っていたのかを調べます。

- 次に、ec2-user のホーム ディレクトリに Spring Pet Clinic サンプル アプリケーションをインストールします。次のコマンドを実行します:

```
cd ~
git clone https://github.com/spring-projects/spring-petclinic.git
```

これで、アプリケーション ファイルが `spring-petclinic` ディレクトリにインストールされていることがわかります。

<!-- ワークショップの EC2 インスタンスには、firewalld はありませんが、firewalld がある場所でこの手順を使用する場合は、次のコマンドを使用してファイアウォールを開きます:

```
sudo firewall-cmd --add-port=8080/tcp
sudo firewall-cmd --add-port=8080/tcp --permanent
```
-->
- データベース サーバーを起動し、アプリケーション用のデータベースを作成する必要があります。次のコマンドを使用して、データベースを有効にして起動します:

```
sudo systemctl enable --now mariadb
```

次に、`mysql` コマンドライン クライアントを使用して、データベース サーバーに接続します。例:

```
mysql --user root
```

`MariaDB [(none)]>` プロンプトが表示されます。このプロンプトで、次の SQL コマンドを入力します:

```
CREATE DATABASE IF NOT EXISTS petclinic;
ALTER DATABASE petclinic DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
GRANT ALL PRIVILEGES ON petclinic.* TO 'petclinic'@'localhost' IDENTIFIED BY 'petclinic';
FLUSH PRIVILEGES;
quit
```

- これで、アプリケーション Web サービスを開始する準備ができました。 バックグラウンドで実行するには、次のコマンドを使用します:

```
echo 'cd $HOME/spring-petclinic && ./mvnw spring-boot:run -Dspring-boot.run.profiles=mysql >> $HOME/app.log 2>&1' | at now
```

- アプリケーションの初回起動には数分かかります。 `app.log` ファイルをチェックして進行状況を追跡し、Web サービスが正常に開始されたことを確認します:

```
tailf ~/app.log
```

この例のように、ログ出力の下部にイベントがリストされている場合、アプリケーションが正常に開始され、テストの準備ができていることを意味します:

```
o.s.b.a.e.web.EndpointLinksResolver : ベース パス '/actuator' の下に 13 個のエンドポイントを公開しています
o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat がポート 8080 (http) でコンテキスト パス '' で開始されました
o.s.s.petclinic.PetClinicApplication : PetClinicApplication を 6.945 秒で開始しました (プロセスは 7.496 秒実行されました)
```

Ctrl-C を入力して `tailf` コマンドを終了します。

### Step 3 - ペットアプリケーションのテスト

アプリケーションをインストールして実行中であることを確認したので、次は動作をテストします。

- このコマンドを使用して、アプリケーションの外部 URL を確認します:

```
echo "http://$(curl -s ifconfig.me):8080"
```

- 新しい Web ブラウザー タブを開きます。上記のコマンドによって出力された URL を切り取って貼り付けます。これで、アプリケーションの Web ユーザー インターフェイスが開きます。アプリケーションが正しく動作している場合は、次のような画面が表示されます:

![ペット クリニック アプリケーションのホームページ](images/petapp_home.svg)

- Web ユーザー インターフェイスの上部にあるさまざまな機能タブを試します。たとえば、"所有者の検索" に移動して、Davis を検索します。所有者レコードの 1 つをクリックして、詳細を表示します。

"所有者の編集" ボタンと "新しいペットの追加" ボタンを使用して、変更を加えたり、新しいレコードを追加したりします。

右上隅の "エラー" タブは、エラー処理テスト機能です。これをクリックすると、予想される結果、"問題が発生しました..." というメッセージが表示され、ランタイム例外とスタック トレースが `app.log` ファイルに記録されます。

- 予想される動作を十分理解できるまで、アプリケーションを操作してください。アップグレード後、再度テストして、影響を受けていないことを確認します。

### Step 4 - 再起動時にアプリケーションが起動するように構成

現時点では、アプリケーションは手動で起動されています。サーバーが再起動されたときにアプリケーションが自動的に起動するように構成する必要があります。

- 次のコマンドを使用して、再起動 cron エントリを構成し、再起動のたびにアプリケーションが自動的に起動されるようにします。

```
echo '@reboot cd $HOME/spring-petclinic && ./mvnw spring-boot:run -Dspring-boot.run.profiles=mysql >> $HOME/app.log 2>&1' | crontab -
```

> **注意**
>
> "PETS / App Install" プレイブックジョブを使用してサンプルアプリをデプロイした場合は、再起動 cron エントリが自動的に作成されるため、上記のコマンドをスキップできます。
>

- 次に、サーバーを再起動して、これが機能することを確認します。

```
sudo reboot
```

- Pet Clinic Web アプリを開いている Web ブラウザーのタブを更新してみてください。サーバーの再起動中に、タイムアウトまたは接続拒否エラーが表示される場合があります。再起動が完了すると、Web アプリは再び動作するはずです。

> **注意**
>
> ワークショップ用にプロビジョニングされた EC2 インスタンスの外部 IP アドレスは動的に割り当てられるため (つまり、DHCP を使用)、再起動後に Web ユーザーインターフェイスの URL が変更される可能性があります。再起動後にアプリにアクセスできない場合は、このコマンドを再度実行して、アプリケーション Web ユーザー インターフェイスの新しい URL を特定します。
>
> ```
> echo "http://$(curl -s ifconfig.me):8080"
> ```
>

FIXME: DNS を使用しないのは恥ずべきことです!

### Step 5 - 別のアップグレード前レポートの実行

サーバーに変更が加えられた場合は、その変更によって新しいリスク検出結果が発生していないことを確認するために、Leapp のアップグレード前レポートを再実行することをお勧めします。

- "AUTO / 01 Analysis" ジョブ テンプレートを起動して、新しいアップグレード前レポートを生成します。ジョブが終了したら、レポートを確認して、新しい検出結果があるかどうかを確認します。前の演習の手順をまだ暗記していない場合は、前の演習の手順を参照してください。

- この高リスク検出結果が今ポップアップしていることに気付きましたか?

![システムで Red Hat によって署名されていないパッケージが見つかりました。高リスクの検出結果](images/packages_not_signed_by_rh.svg)

- 検出結果を開くと、次の詳細が表示されます:

![Red Hat によって署名されていないパッケージの詳細ビュー](images/packages_not_signed_details.svg)

- 「Red Hat によって署名されていないパッケージ」は、サードパーティのパッケージや、アプリ チームが社内で構築したパッケージを指すための、単なる言い回しです。この検出結果の場合、特定されたパッケージは、インストールしたサードパーティの JDK ランタイム パッケージである `temurin-17-jdk` です。この検出結果は、解決できない依存関係がある場合、アップグレード中にこのパッケージが削除されるリスクがあることを警告しています。

パッケージが削除されるかどうかを確実に知る方法は 1 つしかありません。アップグレードを実行して、何が起こるか見てみましょう。

## まとめ

この演習では、従来のアプリケーション メンテナンスの悲惨な状況、追跡されていないドリフト、技術的負債について説明しました。サードパーティの Java ランタイムをインストールし、その上に Pet Clinic アプリケーションをインストールしました。アプリが期待どおりに機能していることを確認しましたが、アップグレード前のレポートで新しい「高リスク」の検出結果も発見しました。

ワークショップの最初のセクションのすべての演習を完了しました。おめでとうございます。次は、RHEL をアップグレードして、アプリケーションに影響があるかどうかを確認します。

---

**ナビゲーション**

[前の演習](../1.5-custom-modules/README.ja.md) - [次の演習](../2.1-upgrade/README.ja.md)

[ホーム](../README.ja.md)
